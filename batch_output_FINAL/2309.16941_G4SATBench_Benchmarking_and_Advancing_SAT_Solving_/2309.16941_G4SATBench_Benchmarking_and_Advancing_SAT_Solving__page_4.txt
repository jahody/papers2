<center>Figure 1: Framework overview of G4SATBench. </center>  

In addition to the diversity of datasets, G4SATBench offers distinct difficulty levels for all datasets to enable fine- grained analyses. These levels include easy, medium, and hard, with the latter representing more complex problems with increased instance sizes. For example, the easy SR dataset contains instances with 10 to 40 variables, the medium SR dataset contains formulas with 40 to 200 variables, and the hard SR dataset consists of formulas with variables ranging from 200 to 400. For each easy and medium dataset, we generate 80k pairs of satisfiable and unsatisfiable instances for training, 10k pairs for validation, and 10k pairs for testing. For each hard dataset, we produce 10k testing pairs. It is also worth noting that the parameters for our synthetic generators are meticulously selected to avoid generating trivial cases. For instance, we produce random 3- SAT formulas at the phase- transition region where the relationship between the number of clauses \((m)\) and variables \((n)\) is \(m = 4.258n + 58.26n^{- 2 / 3}\) (Crawford & Auton, 1996), and utilize the \(v\) vertex Erdős- Rényi graph with an edge probability of \(p = \binom{v}{k}^{- 1 / \binom{v}{2}}\) to generate \(k\) - Clique problems, making the expected number of \(k\) - Cliques in a graph equals 1 (Bollobás & Erdős, 1976). To provide a detailed characterization of our generated datasets, we compute several statistics of the SAT instances across difficulty levels in G4SATBench. Please refer to Appendix A for more information about the datasets.  

### 4.2 GNN Baselines  

Graph constructions. It is important to note that traditional graph representations of a CNF formula often lack the requisite details for optimally constructing GNNs. Specifically, the LIG and VIG exclude clause- specific information, while the LCG and VCG fail to differentiate between positive and negative literals of the same variable. To address these limitations, existing approaches typically build GNN models on the refined versions of the LCG and VCG encodings. In the LCG, a new type of edge is added between each literal and its negation, while the VCG is modified by using two types of edges to indicate the polarities of variables within a clause. These modified encodings are termed the LCG\* and VCG\* respectively, and an example of them is shown in Figure 2. It is also worth noting alternative graph encodings like the And- Inverter- Graph (AIG), can be applied for SAT instances that are not in CNF. However, such representations are specialized to specific applications (like CircuitSAT) and are not designed for general purposes. Given this specialization, we choose to keep them outside the scope of the current G4SATBench.  

<center>Figure 2: LCG\* and VCG\* of the CNF formula \((x_{1} \vee \neg x_{2}) \wedge (x_{1} \vee x_{3}) \wedge (\neg x_{1} \vee x_{2} \vee x_{3})\) . </center>  

tion, while the VCG is modified by using two types of edges to indicate the polarities of variables within a clause. These modified encodings are termed the LCG\* and VCG\* respectively, and an example of them is shown in Figure 2. It is also worth noting alternative graph encodings like the And- Inverter- Graph (AIG), can be applied for SAT instances that are not in CNF. However, such representations are specialized to specific applications (like CircuitSAT) and are not designed for general purposes. Given this specialization, we choose to keep them outside the scope of the current G4SATBench.  

Message- passing schemes. G4SATBench enables performing various heterogeneous message- passage algorithms between neighboring nodes on the LCG\* or VCG\* encodings of a CNF formula. For the sake of illustration, we will take GNN models on the LCG\* as an example. We first define a \(d\) - dimensional embedding for every literal node and clause node, denoted by \(h_{l}\) and \(h_{c}\) respectively. Initially, all these embeddings are assigned to two learnable vectors \(h_{l}^{0}\) and \(h_{c}^{0}\) , depending on their node types. At the \(k\) - th iteration of