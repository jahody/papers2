SAT datasets. Several established SAT benchmarks, including the prestigious SATLIB (Hoos & Stützle, 2000) and the SAT Competitions over the years, have provided a variety of practical instances to assess the performance of modern SAT solvers. Regrettably, these datasets are not particularly amenable for GNNs to learn from, given their relatively modest scale (less than 100 instances for a specific domain) or overly extensive instances (exceeding 10 million variables and clauses). To address this issue, researchers have turned to synthetic SAT instance generators (Giráldez- Cruz & Levy, 2015; 2017; Lauria et al., 2017; Selsam et al., 2019), which allow for the creation of a flexible number of instances with customizable settings. However, most of the existing datasets generated from these sources are limited to a few domains (less than 3 generators), small in size (less than 10k instances), or easy in difficulty (less than 40 variables within an instance), and there is no standardized dataset for evaluation. In G4SATBench, we include a variety of synthetic generators with carefully selected configurations, aiming to construct a broad collection of SAT datasets that are highly conducive for training and evaluating GNNs.  

## 3 Preliminaries  

The SAT problem. In propositional logic, a Boolean formula is constructed from Boolean variables and logical operators such as conjunctions \((\wedge)\) , disjunctions \((\vee)\) , and negations \((\neg)\) . It is typical to represent Boolean formulas in conjunctive normal form (CNF), expressed as a conjunction of clauses, where each clause is a disjunction of literals, which can be either a variable or its negation. Given a CNF formula, the SAT problem is to determine if there exists an assignment of boolean values to its variables such that the formula evaluates to true. If this is the case, the formula is called satisfiable; otherwise, it is unsatisfiable. For a satisfiable instance, one is expected to construct a satisfying assignment to prove its satisfiability. On the other hand, for an unsatisfiable formula, one can find a minimal subset of clauses whose conjunction is still unsatisfiable. Such a set of clauses is termed the unsat core, and variables in the unsat core are referred to as unsat- core variables.  

Graph representations of CNF formulas. Traditionally, a CNF formula can be represented using 4 types of graphs (Biere et al., 2009): Literal- Clause Graph (LCG), Variable- Clause Graph (VCG), Literal- Incidence Graph (LIG), and Variable- Incidence Graph (VIG). The LCG is a bipartite graph with literal and clause nodes connected by edges indicating the presence of a literal in a clause. The VCG is formed by merging the positive and negative literals of the same variables in LCG. The LIG, on the other hand, only consists of literal nodes, with edges indicating co- occurrence in a clause. Lastly, the VIG is derived from LIG using the same merging operation as VCG.  

## 4 G4SATBench: A Benchmark Study on GNNs for SAT Solving  

The goal of G4SATBench is to establish a general framework that enables comprehensive comparisons and evaluations of various GNN- based SAT solvers. In this section, we will delve into the details of G4SATBench, including its datasets, GNN models, prediction tasks, as well as training and testing methodologies. The overview of the G4SATBench framework is shown in Figure 1.  

### 4.1 Datasets  

G4SATBench is built on a diverse set of synthetic CNF generators. It currently consists of 7 datasets sourced from 3 distinct domain areas: random problems, pseudo- industrial problems, and combinatorial problems. Specifically, we utilize the SR generator in NeuroSAT (Selsam et al., 2019) and the 3- SAT generator in CNFGen (Lauria et al., 2017) to produce random CNF formulas. For pseudo- industrial problems, we employ the Community Attachment (CA) model (Giráldez- Cruz & Levy, 2015) and the Popularity- Similarity (PS) model (Giráldez- Cruz & Levy, 2017), which generate synthetic instances that exhibit similar statistical features, such as the community and the locality, to those observed in real- world industrial SAT instances. For combinatorics, we resort to 3 synthetic generators in CNFGen (Lauria et al., 2017) to create SAT instances derived from the translation of \(k\) - Clique, \(k\) - Dominating Set, and \(k\) - Vertex Cover problems.