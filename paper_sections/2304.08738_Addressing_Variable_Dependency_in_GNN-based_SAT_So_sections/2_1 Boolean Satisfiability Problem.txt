The Boolean satisfiability problem talks about propositional logic with Boolean variables and Boolean operators like "and" \((\wedge)\) , "or" \((\vee)\) , "not" \((\neg)\) . The problem is to decide whether there exist assignments to the Boolean variables so that a given propositional logic formula evaluates to true under such assignment. The expected answer is either satisfi  

able (SAT) or unsatisfiable (UNSAT). In case the formula is satisfiable, we also expect to know the satisfying variable assignment.  

In Boolean satisfiability problem, the input is usually a Boolean formula in the conjunctive norm form (CNF). In CNF, the variables and their negations are called the literals, which are first connected with disjunctions \((\vee)\) to form the clauses. The clauses are then connected with conjunctions \((\wedge)\) . An arbitrary Boolean formula can always be converted into CNF using Boolean algebra, though the number of clauses may exponentially blow up. Alternatively, Tseitin transformation [Tseitin, 1983] converts a formula into an equi- satisfiable CNF, whose size is linear to the number of operators in the original one. Therefore, it is the preferred solution of CNF conversion in modern SAT solving.  

Besides CNF, the input of SAT could also be a circuit, which is essentially a directed acyclic graph (DAG) with each node representing either a circuit input, a logic gate or the circuit output. The goal is to find an input combination that causes the circuit output to become 1. The circuit form is more natural in some applications (for example, EDA). Note that the circuit form can be converted into a CNF formula by introducing new variables, and the number of clauses and variables in the converted CNF is proportional to the number of graph nodes in the circuit DAG [Prestwich, 2009]. On the other hand, a CNF formula can also be converted back into a circuit form, as presented in [Amizadeh et al., 2018, Appendix C].