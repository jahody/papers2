S.3.1 Random Problems. The generative model proposed by [29] samples formulas in sat/unsat pairs which differ only by a negation of a single literal in one clause. This is accomplished through the sequential sampling of clauses which are continuously added to the CNF formula until it becomes unsatisfiable. To create a new clause, the generative model first samples a small integer, \(k\) , and then randomly selects \(k\) variables without replacement. Each selected variable is independently negated with a probability 0.5 and the resulting literal is added to the clause. Satisfiability is determined by querying a solver right after the addition of a new clause. When the problem becomes unsatisfiable, it is paired with a satisfiable problem which is exactly the same except that in the last added clause, one literal is negated. The sampling of \(k\) is designed to vary the size of clauses while avoiding an excessive number of two-literal clauses, which would simplify the problem on average.
S.3.2 Structured Problems. While many works evaluate NN-based SAT solvers on randomly generated problems, it is far more compelling to understand their performance on problems representing facets of human reasoning. The objective is to generate data that is reflecting various degrees of difficulty of Boolean reasoning. Since real-world problems often produce a large number of variables and clauses, which can be easily reduced by preprocessing, we uniformly reduce all the instances by unit propagation, which can be realized in polynomial time (see following paragraph).  

Unit propagation. is one of the simplest operation for propositional logic, which propagates unit clauses in a CNF \(\phi\) . The process consists of identifying a unit clause \(\{l\} \in \phi\) , then removing all clauses from \(\phi\) that contain \(\phi\) and removing the complementary literal \(l\) from all the other clauses. This process may create new unit clauses, which are then propagated in the same manner. If the process produces the empty clause (semantically equivalent to false), then the formula \(\phi\) is unsatisfiable. We can say that a formula is solved by unit propagation if the unit operation derives the empty clause, or if all remaining clauses are unit clauses.  

Latin square. is an \(n\times n\) grid of numbers \(1..n\) , where each number appears exactly once in each row and in each column. We generate SAT instances by partially filling the Latin square—the individual values in the partially filled Latin square are referred to as hints. Then, the task is to decide whether the given hints can be completed in to a full Latin square (similarly to the Sudoku puzzle). In order to generate interesting instances, we generate instances that have a unique solution and are minimal in the sense that removing any of the hints leads to multiple solutions. This is generated as follows. First generate a valid random Latin square and then start removing values of individual squares, at random, while a unique solution exists—this is checked by a SAT solver. The resulting formula consists of the rules of the Latin square and a set of unit clauses representing the hints. This process generates a satisfiable SAT instance with a unique solution. An unsatisfiable instance is generated by adding a single random hint incongruent with the unique solution.  

Sudoku. is a popular puzzle, which is in fact an extension of latin squares Where we add additional constraints on smaller squares (aka boxes). We consider the standard format where the puzzle is composed of \(3\times 3\) boxes, which comprise \(3\times 3\) cells to be filled. We use the same method as in Latin squares to generate interesting puzzles.  

Logical circuits. Are one of the main means of modeling in SAT. Indeed, they enable modeling digital systems but also represent a powerful intermediate language for modeling propositional problems. An important application of SAT are bit- vector problems of a fixed bit- width. To represent this type of reasoning, we generate problems of the form  

\[c_{1}*r_{1} + c_{2}*r_{2}\neq c_{3}\mod 2^{n}\]  

We use the Model checker CBMC to convert these inequalities to CNF [7].