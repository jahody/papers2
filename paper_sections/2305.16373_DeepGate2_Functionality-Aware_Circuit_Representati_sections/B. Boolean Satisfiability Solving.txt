Boolean satisfiability (SAT) solving is a long- standing and fundamental NP- complete problem with applications in many areas, especially in electronic design automation (EDA) [31]- [33]. The existing SAT solvers are designed to incorporate efficient heuristics [34]- [36] to expedite the solving process. For instance, [34] proposes to utilize the correlation of logic gate functionality to enforce variable decision for solving circuit- based SAT instances. Although the solution achieves remarkable speedup over SAT solvers, it still relies on the time- consuming logic simulation to obtain the functionality. Based on [34], we demonstrate how the DeepGate2 models functional correlation efficiently and accelerates SAT solving.  

1) Experiment Settings: We integrate our DeepGate2 into a modern SAT solver, CaDiCal [15] to solve the instances from logic equivalence checking (LEC) task. Firstly, we obtain gate-level embeddings of the original circuit and predict the pairwise functional similarity between these gates. Given the one-to-one mapping [37] between circuits and conjunctive normal form (a problem format required by SAT solvers), we can easily transfer the gate functional similarity to variable behavioral similarity. If two logic gates have similar representations (and therefore similar functionality), their corresponding variables should be correlated and grouped together during the variable decision process.  

Secondly, we incorporate the learnt knowledge into the SAT solver. As shown in Algorithm 1, when the current variable \(s\) is assigned a value \(v\) , we identify all unassigned variables \(s'\) in the set \(S\) that contains correlated variables with \(s\) . As modern SAT solvers reduce searching space by detecting conflicts as much as possible [38], we assign the reverse value \(\bar{v}\) to \(s'\) to promptly cause conflict for joint decision. Besides, the threshold \(\delta\) in Algorithm 1 is set to \(1e - 5\) .  

Thirdly, to evaluate the efficacy of our model in accelerating SAT solving, we compare the aforementioned hybrid solver (labeled as Our) with original CaDiCal [15] (labeled as Baseline) on 5 industrial instances. All experiments are conducted with a single 2.40GHz Intel(R) Xeon(R) E5- 2640 v4 CPU.  

2) Results: The runtime comparison between Baseline and Our are listed in Table VII. To ensure a fair comparison, we aggregate the DeepGate2 model inference time (Model) and SAT solver runtime (Solver) as the Overall runtime. We have the following observations.  

Algorithm 1 Variable Decision Function with DeepGate2 Current variable \(s\) just being assigned a value \(v\) ; Set \(S\) containing the correlated variables with \(s\) ;  

Function \(\mathrm{Sim}(s_i,s_j)\) to calculate the behaviour similarity of two variables;  

\(\delta\) is the threshold for the joint decision Function \(V(s)\) to get the assigned value of variable \(s\) ; Function Decision \((s,v)\) to assign the decision value \(v\) to the current decision variable \(s\) .  

1: Decision \((s,v)\)  

2: for \(s'\) in \(S\) do  

3: if \(s' \neq s\) and \(V(s') = \text{None}\) then  

4: if \(\mathrm{Sim}(s',s) > 1 - \delta\) then  

5: Decision \((s',\bar{v})\)  

6: end if  

7: end if  

8: end for  

TABLE VII COMPARING THE RUNTIME BETWEEN BASELINE AND OUR SOLVERS   

<table><tr><td rowspan="2">Instance</td><td rowspan="2">Size</td><td rowspan="2">Baseline(s)</td><td colspan="2">Our(s)</td><td rowspan="2">Reduction</td></tr><tr><td>Model</td><td>Solver</td></tr><tr><td>I1</td><td>17,495</td><td>88.01</td><td>1.77</td><td>30.25</td><td>32.02</td></tr><tr><td>I2</td><td>21,952</td><td>29.36</td><td>2.85</td><td>6.01</td><td>8.86</td></tr><tr><td>I3</td><td>23,810</td><td>61.24</td><td>3.25</td><td>32.88</td><td>36.13</td></tr><tr><td>I4</td><td>27,606</td><td>158.04</td><td>4.36</td><td>137.77</td><td>142.13</td></tr><tr><td>I5</td><td>28,672</td><td>89.89</td><td>4.78</td><td>70.95</td><td>75.73</td></tr><tr><td>Avg.</td><td></td><td></td><td></td><td></td><td>40.05%</td></tr></table>  

First, our method achieves a substantial reduction in total runtime for all test cases, with an average runtime reduction of \(40.05\%\) . Take I1 as an example, the plain solver requires \(88.01\mathrm{s}\) to solve the problem, but by combining with our model, the new solver produces results in only 32.02s, reducing runtime by \(63.62\%\) . Second, our model only takes a few seconds to obtain embeddings, occupying less than \(10\%\) of overall runtime on average. It should be noted that our DeepGate2 is able to infer within polynomial time that is only proportional to the size of instance. Third, while the two largest instances I4 and I5 show less reduction than the others, it does not necessarily mean that our model is unable to generalize to larger instances. As evidenced by the results for I2, an instance with a similar size to I4 and I5 also demonstrates a significant reduction. The reduction caused by our model should be determined by the characteristics of instance. In summary, our model is effective in speeding up downstream SAT solving.