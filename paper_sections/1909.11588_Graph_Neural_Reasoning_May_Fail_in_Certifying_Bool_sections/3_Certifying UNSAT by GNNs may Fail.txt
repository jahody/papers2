Although existing researches showed that GNN can learn a well- performed solver for satisfiability problems, GNN- based SAT solvers actually have terrible performances in predicting unsatisfiability with high confidence [12] in a SAT formula, if the formula does not have a small unsatisfiable core (minimal number of clauses that is enough to cause unsatisfiability). In fact, some previous work [1] even completely removed unsatisfiable formulas from the training dataset, since they slowed down the whole training process.  

The difficulty in proving unsatisfiability is understandable, since constructing a proof of unsatisfiability demands a complete reasoning in the search space, which is more complex than constructing a proof of satisfiability that only requires a witness. Traditionally it relies on the recursive decision procedures that either traverse all possible assignments to construct the proof (DPLL [4]), or generate extra constraints from assignment trials that lead to conflicts, until some of the constraints contradict each other (CDCL [13]). The line of recursive algorithms include some operation branches that reconfigure the bipartite graph behind the CNF in each step while they search. In the terms of a graph that may iteratively change (e.g., DPLL), perhaps miserably, their recursive processes can not be simulated by GNNs.  

Observation 3.1. Given a recursive algorithm that iteratively reconfigures the graph, GNNs in Eq.2 can not simulate this recursive process.  

Proof. Associating the aggregate and combine functions in Eq. 2, we obtain the iterative update rule for the embedding of a literal \(v\) :  

\[\begin{array}{r l} & {h_{v}^{(k)} = \mathrm{Combine}_{L}^{(k)}\left(h_{v}^{(k - 1)},h_{v - v}^{(k - 1)},\mathrm{Aggregate}_{L}^{(k)}\left(\{h_{\Psi (v)}^{(k - 1)}:\Psi (v)\in \Phi \}\right)\right)}\\ & {\quad = \mathrm{Update}_{L}^{(k)}\left(h_{v}^{(k - 1)},h_{v - v}^{(k - 1)},\{h_{\Psi (v)}^{(k - 1)}:\Psi (v)\in \Phi \}\right),}\\ & {\quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad s.t.v\in L} \end{array} \quad (3)\]  

Towards this principle, we observe that the embedding update of \(v\) in the current stage relies on the last- stage embeddings of \(v\) and its negation \(\neg v\) , and the embeddings of all the clauses that include \(v\) in a CNF formula \((\Psi (v) \in \Phi)\) . The literal \(v\) , \(\neg v\) and the clauses containing \(v\) are consistent over iterations. Hence if the update function (Eq. 3) is consistent over the iterations in Eq.2, i.e., \(\forall k \in \mathbb{N}_{+}\) , \(\mathrm{Update}_{L}^{(k)} = \mathrm{Update}_{L}\) , where \(\mathrm{Update}_{L}\) means the update for literal embedding, GNNs derived from Eq. 3 receive a fixed graph generated by a CNF formula as input. However, if a recursive algorithm iteratively changes the graph that represents a CNF formula, it implies that there must be a clause that was changed (or eliminated) after this iteration, since clauses are permutation- invariant in a CNF formula. Accordingly there must be a literal embedding whose update process depends on a clause different from the previous iteration. It contradicts the literal embedding update function learned by Eq. 3 with \(\forall k \in \mathbb{N}_{+}\) , \(\mathrm{Update}_{L}^{(k)} = \mathrm{Update}_{L}\) .  

Hence the message- passing in GNNs could not resemble the procedures in the complete SAT- solvers. In fact, GNNs are rather similar to learning a subfamily of incomplete SAT solvers (GSAT, WalkSAT [11]), which randomly assign variables and stochastically search for local witnesses.  

Observation 3.2. GNNs in Eq. 2 may simulate the local search in WalkSAT.  

Proof. Recall the iterative update routine of WalkSAT: starting by assigning a random value to each literal variable in a formula, it randomly chooses an unsatisfied clause in the formula and flips the value of a Boolean variable within that clause. Such process is repeated till the literal assignment satisfies all clauses in the formula. Here we construct the optimal aggregation and combine functions derived from Eq. 2, which are designed to simulate the procedure of WalkSAT. In this way, if the aggregation and combine functions in Eq. 2 approximate these optimal aggregation and combine functions, the GNN may simulate the local search in WalkSAT.  

Given a universe of literals in logical reasoning, we first initiate the embeddings of them and their negation, thus, \(\forall v \in L\) , random value of \(h_{v}^{(0)}\) and \(h_{\neg v}^{(0)}\) are initiated. This assignment can be treated as the Boolean value that belong to different literals, which have been mapped from a binary vector into a real- value embedding space about the literals. We also randomly initiate the clause embeddings \(h_{\Psi (v)}^{(0)}\) for reasoning each formula that contains the clause \(\Psi (v)\) . Here we define the optimal
aggregation and combine functions that encode literals and clauses respectively, which GNNs in Eq. 2 may learn if they attempt to simulate WalkSAT:  

\[\begin{array}{r l} & {m_{v}^{(k)} = \overline{{\mathrm{Aggregate}}}_{L}\Big(\{h_{\Psi^{(v)}}^{(k - 1)}:\Psi (v)\in \Phi \} \Big),}\\ & {\qquad = \left\{ \begin{array}{l l}{\epsilon^{(k)},} & {\prod_{\Psi (v)}||h_{\Psi^{(v)}}^{(k - 1)}|| = 0}\\ {\qquad 0,} & {\prod_{\Psi (v)}||h_{\Psi^{(v)}}^{(k - 1)}||\neq 0} \end{array} \right.} \end{array} \quad (4)\]  

where \(\overline{{\mathrm{Aggregate}}}_{L}(\cdot)\) denotes the optimal aggregation function to propagate literal messages and \(m_{v}^{(k)}\) denotes the optimally propagated message of literal \(v\) in the \(k\) iteration; \(\mathbf{0}\) is a zero- value vector; \(\epsilon^{(k)}\) denotes a bounded non- zero random vector generated in the \(k\) iteration; \(||\cdot ||\) indicates a vector norm.  

\[\begin{array}{r l} & {h_{v}^{(k)} = \overline{{\mathrm{Combine}}}_{L}\Big(h_{v}^{(k - 1)},h_{v - v}^{(k - 1)},m_{v}^{(k)}\Big)}\\ & {\qquad = \left\{ \begin{array}{l l}{h_{v - v}^{(k - 1)},} & {v = \arg \max \{\big||m_{u}^{(k)}\big||\} \mathrm{and} \big||m_{v}^{(k)}\big|| > 0}\\ {h_{v}^{(k - 1)},} & {\mathrm{otherwise}} \end{array} \right.} \end{array} \quad (5)\]  

where \(\overline{{\mathrm{Combine}}}_{L}(\cdot)\) denotes the optimal combine function that iteratively updates literal embeddings by the aid of the optimal message. Eq. 5 implies the local Boolean variable flipping in WalkSAT: if the norm of \(m_{v}^{(k)}\) is the maximum among all the optimal literal messages, its literal embedding would be replaced by the embedding of its negation, otherwise, keep the identical value. The maximization ensures only one literal embedding that would be "flipped" per iteration, which simulates the local search behavior. Besides, the literal embedding selected for update would not be \(\mathbf{0}\) , which implies all the clauses containing this literal are satisfied (see the condition 2 in Eq. 4 ). Since all the satisfied clauses would not be selected in WalkSAT, this literal also would not be selected to update in this iteration. Finally, if a literal has been included by a clause that is unsatisfied, it would be randomly picked in some probability. The uncertainty is implied by the randomness of \(\epsilon^{(k)}\) .  

\[\begin{array}{r l} & {m_{\Psi^{(v)}}^{(k)} = \overline{{\mathrm{Aggregate}}}_{C}\big(\{h_{u}^{(k - 1)}:u\in \Psi (v)\} \big)}\\ & {\qquad = \left\{ \begin{array}{l l}{h_{\Psi^{(v)}}^{(0)},} & {\mathrm{Sigmoid}\Big(\mathrm{MLP}_{2}^{*}\Big(\sum_{u\in \Psi (v)}\mathrm{MLP}_{1}^{*}(h_{u}^{(k - 1)})\Big)\Big)\geq 0.5}\\ {0,} & {\mathrm{Sigmoid}\Big(\mathrm{MLP}_{2}^{*}\Big(\sum_{u\in \Psi (v)}\mathbf{MLP}_{1}^{*}(h_{u}^{(k - 1)})\Big)\Big)< 0.5} \end{array} \right.} \end{array} \quad (6)\]  

where \(\overline{{\mathrm{Aggregate}}}_{C}(\cdot)\) denotes the optimal aggregation function that conveys the clause embedding messages during reasoning. Note that \(\mathrm{MLP}_{2}\Big(\sum_{u\in \Psi (v)}\mathrm{MLP}_{1}(h_{u}^{(k - 1)})\Big)\) indicates Deep Sets [18], a neural network that encodes a literal embedding set \(\{h_{u}^{(k - 1)}\}_{u\in \Psi (v)}\) whose literals are included by a clause \(\Psi (v)\) . The reduced feature would be fed into the sigmoid clause predictor. We use \(\mathrm{MLP}_{1}^{*}\) and \(\mathrm{MLP}_{2}^{*}\) to denote the implicit optimal prediction to each clause: given the arbitrarily initiated literal embeddings that denote the Boolean value assignment of literals, the optimal Deep Sets can predict whether the literal- derived clause is satisfied \((\geq 0.5)\) or not \((< 0.5)\) . Since the predictor is permutation- invariant to the input, Propositions 3.1 in [15] promises that it can be approximated arbitrarily closely by graph convolution, which exactly corresponds to the parameterized clause aggregation functions in Eq.2. On the other hand, Eq. 5 promises the literal embeddings staying in their initiated values over iterations, hence the optimal Deep Sets may always judge whether a clause (the set of literals as the input of Deep Sets) is satisfied or not.  

\[\begin{array}{r l} & {h_{\Psi^{(v)}}^{(k)} = \overline{{\mathrm{Combine}}}_{C}\Big(h_{\Psi^{(v)}}^{(k - 1)},m_{\Psi^{(v)}}^{(k)}\Big)}\\ & {\qquad = \left\{ \begin{array}{l l}{h_{\Psi^{(v)}}^{(k - 1)},} & {h_{\Psi^{(v)}}^{(k - 1)} = m_{\Psi^{(v)}}^{(k)}}\\ {h_{\Psi^{(v)}}^{(0)},} & {||h_{\Psi^{(v)}}^{(k - 1)}||< ||m_{\Psi^{(v)}}^{(k)}||}\\ {0,} & {||h_{\Psi^{(v)}}^{(k - 1)}||\geq ||m_{\Psi^{(v)}}^{(k)}||} \end{array} \right.} \end{array} \quad (7)\]  

where \(\overline{{\mathrm{Combine}}}_{C}(\cdot)\) denotes the optimal clause combine function. Based on the propagated messages conveyed by Eq. 2 , it determines how to iteratively update clause embeddings to simulate WalkSAT.
Here we elaborate how the four optimal functions above cooperate to simulate an iteration of Walk- SAT. Since GNNs use literal embeddings as the initial input, we first analyze Eq. 6 and takes a literal \(v\) into our consideration. As we discussed, this function receives a set of literal embeddings that denotes a clause that contains \(v\) , and then, takes the optimal Deep Sets as an oracle to judge whether this clause is satisfied. The output, the optimal message about the clause, equals to the initiated embedding of the clause \(h_{\Psi (v)}\) if it is satisfied, otherwise becomes 0. This process simulates the logical reasoning on a clause, which WalkSAT relies on to pick an unsatisfied clause and flip one of its variables (see Eq. 5). Based on \(m_{\Psi (v)}^{(k)}\) , the optimal clause combine function (Eq. 7) updates an arbitrary clause embedding that contains \(v\) . The first branch states that, if the current clause message \(m_{\Psi (v)}^{(k)}\) is consistent with the previous clause embedding \(h_{\Psi (v)}^{(k - 1)}\) , it implies the satisfiability of the clause \(\Psi (v)\) is not changed in this iteration (the previously satisfied clause is still satisfied, vice and versa). In this case the clause embedding would not be updated. The second and third branches imply that when \(m_{\Psi (v)}^{(k)}\) and \(h_{\Psi (v)}^{(k - 1)}\) are inconsistent, how to update the clause embedding \(h_{\Psi (v)}^{(k)}\) to convey the current message about whether the clause \(\Psi (v)\) is satisfied (return into the initial clause embeddings) or not (turn into 0). Therefore all updated embeddings about the clauses that contain \(v\) , as the neighbors of \(v\) , would be fed into the optimal aggregation function in Eq. 4. This function selects \(v\) that only exists in satisfied clauses, i.e., \(\prod_{\Psi (v)}||h_{\Psi (v)}^{(k)}||\neq 0\) (If there is an unsatisfied clauses, its embedding is 0 according to Eq. 7, and would lead to \(\prod_{\Psi (v)}||h_{\Psi (v)}^{(k)}|| = 0\) ), then the embedding of \(v\) would become 0. The results by this operation are taken advantage by Eq. 5, which promises the literal that only exists in satisfied clauses would not be "flipped" (WalkSAT only chooses unsatisfied clause and select its variables to flip. If literals are not in any unsatisfied clauses, it would not be chosen). Towards the literal \(v\) contained by one unsatisfied clause at least \((\prod_{\Psi (v)}||h_{\Psi (v)}^{(k)}|| = 0\) since there exists a clause embedding equals to 0 according to Eq. 7), its literal message would be assigned by a random vector \(\epsilon^{(k)}\) . It implies the randomness when WalkSAT try to select one of literal in unsatisfied clauses to flip its value. The flipping process is simulated by Eq. 6 as we have discussed.  

Here we further verify if a CNF formula could be satisfied, literal embeddings generated by the optimal aggregation and combine functions that represent the Boolean assignment of literal to satisfy this CNF formula, would converge over iterations (It corresponds to the stop criteria in Walk- SAT). Specifically suppose that in the \(k\) - 1 iteration, Eq. 5 have induced the literal embeddings so that all clauses with the literal in the formula have been satisfied. By Eq. 6 it is obvious that \(\forall v\in L\) , \(m_{\Psi (v)}^{(k)} = h_{\Psi (v)}^{(0)}\) . To this we have \(h_{\Psi (v)}^{(k - 1)} = m_{\Psi (v)}^{(k)}\) and \(h_{\Psi (v)}^{(k)} = h_{\Psi (v)}^{(k - 1)} = h_{\Psi (v)}^{(0)}\) since all clauses in the formula have already been satisfied before the current iteration. In this case, it holds \(\prod_{\Psi (v)}||h_{\Psi (v)}^{(k - 1)}||\neq 0\) and leads to \(\forall v\in L\) , \(m_{v}^{(k)} = 0\) in this formula (Eq. 4). In term of this, Eq. 5 guarantees all the literal embeddings consistent with those in the previous iteration.  

Concluding the analysis above, we know that the optimal aggregation and combine functions (Eq. 4 5 6 7 ) are cooperated to simulate the local search in WalkSAT.  

Failure in 2QBF. Notably the failure in proving UNSAT would not be a problem for GNNs applied to solve SAT, as predicting satisfiability with high confidence has already been good enough for a binary distinction. However, 2QBF problems imply solving UNSAT, which inevitably makes GNNs unavailable in proving the relevant formulae. It probably explains the mystery in[7] about why GNNs purely learned by data- driven supervised learning lead to the same performances as random speculation [16].